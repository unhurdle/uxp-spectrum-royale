/**
 * Generated by Apache Royale Compiler from org/apache/royale/geom/Matrix.as
 * org.apache.royale.geom.Matrix
 *
 * @fileoverview
 *
 * @suppress {missingRequire|checkTypes|accessControls}
 */

goog.provide('org.apache.royale.geom.Matrix');
/* Royale Dependency List: org.apache.royale.geom.Point*/




/**
 * @constructor
 * @param {number=} a
 * @param {number=} b
 * @param {number=} c
 * @param {number=} d
 * @param {number=} tx
 * @param {number=} ty
 */
org.apache.royale.geom.Matrix = function(a, b, c, d, tx, ty) {
  a = typeof a !== 'undefined' ? a : 1;
  b = typeof b !== 'undefined' ? b : 0;
  c = typeof c !== 'undefined' ? c : 0;
  d = typeof d !== 'undefined' ? d : 1;
  tx = typeof tx !== 'undefined' ? tx : 0;
  ty = typeof ty !== 'undefined' ? ty : 0;
  this.a = a;
  this.b = b;
  this.c = c;
  this.d = d;
  this.tx = tx;
  this.ty = ty;
};


/**
 * @type {number}
 */
org.apache.royale.geom.Matrix.prototype.a;


/**
 * @type {number}
 */
org.apache.royale.geom.Matrix.prototype.b;


/**
 * @type {number}
 */
org.apache.royale.geom.Matrix.prototype.c;


/**
 * @type {number}
 */
org.apache.royale.geom.Matrix.prototype.d;


/**
 * @type {number}
 */
org.apache.royale.geom.Matrix.prototype.tx;


/**
 * @type {number}
 */
org.apache.royale.geom.Matrix.prototype.ty;


/**
 *	Returns a copy of the Matrix
 *  @langversion 3.0
 *  @playerversion Flash 10.2
 *  @playerversion AIR 2.6
 *  @productversion Royale 0.7
 * @return {org.apache.royale.geom.Matrix}
 */
org.apache.royale.geom.Matrix.prototype.clone = function() {
  return new org.apache.royale.geom.Matrix(this.a, this.b, this.c, this.d, this.tx, this.ty);
};


/**
 *  Adds the Matrix the current one
 *  Returns the matrix so the methods can be chained.
 *  @langversion 3.0
 *  @playerversion Flash 10.2
 *  @playerversion AIR 2.6
 *  @productversion Royale 0.7
 * @param {org.apache.royale.geom.Matrix} m
 * @return {org.apache.royale.geom.Matrix}
 */
org.apache.royale.geom.Matrix.prototype.concat = function(m) {
  var /** @type {number} */ newa = this.a * m.a + this.b * m.c;
  this.b = this.a * m.b + this.b * m.d;
  this.a = newa;
  var /** @type {number} */ newc = this.c * m.a + this.d * m.c;
  this.d = this.c * m.b + this.d * m.d;
  this.c = newc;
  var /** @type {number} */ newtx = this.tx * m.a + this.ty * m.c + m.tx;
  this.ty = this.tx * m.b + this.ty * m.d + m.ty;
  this.tx = newtx;
  return this;
};


/**
 *  Calculates the Matrix determinant
 *  @langversion 3.0
 *  @playerversion Flash 10.2
 *  @playerversion AIR 2.6
 *  @productversion Royale 0.7
 * @return {number}
 */
org.apache.royale.geom.Matrix.prototype.determinant = function() {
  return this.a * this.d - this.b * this.c;
};


/**
 *  Inverts the Matrix.
 *  Returns the matrix so the methods can be chained.
 *  @langversion 3.0
 *  @playerversion Flash 10.2
 *  @playerversion AIR 2.6
 *  @productversion Royale 0.7
 * @return {org.apache.royale.geom.Matrix}
 */
org.apache.royale.geom.Matrix.prototype.invert = function() {
  if (this.b == 0 && this.c == 0) {
    this.a = 1 / this.a;
    this.d = 1 / this.d;
    this.tx *= -this.a;
    this.ty *= -this.d;
  } else {
    var /** @type {number} */ det = this.determinant();
    if (det == 0) {
      this.identity();
      return this;
    }
    det = 1 / det;
    var /** @type {number} */ newa = this.d * det;
    this.d = this.a * det;
    this.a = newa;
    this.b *= -det;
    this.c *= -det;
    var /** @type {number} */ newtx = -this.a * this.tx - this.c * this.ty;
    this.ty = -this.b * this.tx - this.d * this.ty;
    this.tx = newtx;
  }
  return this;
};


/**
 *  Resets the matrix to the default values.
 *  Returns the matrix so the methods can be chained.
 *  @langversion 3.0
 *  @playerversion Flash 10.2
 *  @playerversion AIR 2.6
 *  @productversion Royale 0.7
 * @return {org.apache.royale.geom.Matrix}
 */
org.apache.royale.geom.Matrix.prototype.identity = function() {
  this.a = this.d = 1;
  this.b = this.c = this.tx = this.ty = 0;
  return this;
};


/**
 *  Rotates the Matrix by the specified value.
 *  Returns the matrix so the methods can be chained.
 *  @langversion 3.0
 *  @playerversion Flash 10.2
 *  @playerversion AIR 2.6
 *  @productversion Royale 0.7
 * @param {number} angle
 * @return {org.apache.royale.geom.Matrix}
 */
org.apache.royale.geom.Matrix.prototype.rotate = function(angle) {
  var /** @type {number} */ cos = Math.cos(angle);
  var /** @type {number} */ sin = Math.sin(angle);
  var /** @type {number} */ newa = this.a * cos - this.b * sin;
  this.b = this.a * sin + this.b * cos;
  this.a = newa;
  var /** @type {number} */ newc = this.c * cos - this.d * sin;
  this.d = this.c * sin + this.d * cos;
  this.c = newc;
  var /** @type {number} */ newtx = this.tx * cos - this.ty * sin;
  this.ty = this.tx * sin + this.ty * cos;
  this.tx = newtx;
  return this;
};


/**
 *  Moves the Matrix by the specified amount
 *  Returns the matrix so the methods can be chained.
 *  @langversion 3.0
 *  @playerversion Flash 10.2
 *  @playerversion AIR 2.6
 *  @productversion Royale 0.7
 * @param {number} x
 * @param {number} y
 * @return {org.apache.royale.geom.Matrix}
 */
org.apache.royale.geom.Matrix.prototype.translate = function(x, y) {
  this.tx += x;
  this.ty += y;
  return this;
};


/**
 *  Scales the Matrix by the specified amount.
 *  Returns the matrix so the methods can be chained.
 *  @langversion 3.0
 *  @playerversion Flash 10.2
 *  @playerversion AIR 2.6
 *  @productversion Royale 0.7
 * @param {number} x
 * @param {number} y
 * @return {org.apache.royale.geom.Matrix}
 */
org.apache.royale.geom.Matrix.prototype.scale = function(x, y) {
  this.a *= x;
  this.b *= y;
  this.c *= x;
  this.d *= y;
  this.tx *= x;
  this.ty *= y;
  return this;
};


/**
 *  Uses the Matrix to transform the point without the translation values.
 *  Returns a new Point. The original Point is unchanged.
 *  @langversion 3.0
 *  @playerversion Flash 10.2
 *  @playerversion AIR 2.6
 *  @productversion Royale 0.7
 * @param {org.apache.royale.geom.Point} point
 * @return {org.apache.royale.geom.Point}
 */
org.apache.royale.geom.Matrix.prototype.deltaTransformPoint = function(point) {
  return new org.apache.royale.geom.Point(this.a * point.x + this.c * point.y, this.d * point.y + this.b * point.x);
};


/**
 *  Uses the Matrix to transform the point including the translation values.
 *  Returns a new Point. The original Point is unchanged.
 *  @langversion 3.0
 *  @playerversion Flash 10.2
 *  @playerversion AIR 2.6
 *  @productversion Royale 0.7
 * @param {org.apache.royale.geom.Point} point
 * @return {org.apache.royale.geom.Point}
 */
org.apache.royale.geom.Matrix.prototype.transformPoint = function(point) {
  return new org.apache.royale.geom.Point(this.a * point.x + this.c * point.y + this.tx, this.d * point.y + this.b * point.x + this.ty);
};


/**
 * Creates the specific style of matrix expected by the certain methods of the swf Graphics emulation class in the Graphics library.
 * @asparam width The width of the gradient box.
 * @asparam height The height of the gradient box.
 * @asparam rotation (default = 0) — The amount to rotate, in radians.
 * @asparam tx (default = 0) — The distance, in pixels, to translate to the right along the x axis. This value is offset by half of the width parameter.
 * @asparam ty (default = 0) — The distance, in pixels, to translate down along the y axis. This value is offset by half of the height parameter.
 *
 * This method is not reflectable in javascript, to allow for dead-code-elimination in applications that will not use it.
 * If it is required for reflection, you can create a subclass, and overrride this method, simply calling the super method with the original arguments.
 * That change will make it reflectable in the subclass.
 * @royalesuppressexport
 * @param {number} width
 * @param {number} height
 * @param {number=} rotation
 * @param {number=} tx
 * @param {number=} ty
 */
org.apache.royale.geom.Matrix.prototype.createGradientBox = function(width, height, rotation, tx, ty) {
  rotation = typeof rotation !== 'undefined' ? rotation : 0;
  tx = typeof tx !== 'undefined' ? tx : 0;
  ty = typeof ty !== 'undefined' ? ty : 0;
  this.tx = tx + width / 2;
  this.ty = ty + height / 2;
  this.a = width / 1638.4;
  this.d = height / 1638.4;
  if (rotation !== 0) {
    var /** @type {number} */ cos = Math.cos(rotation);
    var /** @type {number} */ sin = Math.sin(rotation);
    this.c = -sin * this.a;
    this.b = sin * this.d;
    this.a = cos * this.a;
    this.d = cos * this.d;
  } else {
    this.c = this.a * 0;
    this.b = this.d * 0;
  }
};


/**
 *  Returns a string representation of the Matrix.
 *  @langversion 3.0
 *  @playerversion Flash 10.2
 *  @playerversion AIR 2.6
 *  @productversion Royale 0.7
 * @return {string}
 */
org.apache.royale.geom.Matrix.prototype.toString = function() {
  return "(a=" + this.a + ", b=" + this.b + ", c=" + this.c + ", d=" + this.d + ", tx=" + this.tx + ", ty=" + this.ty + ")";
};


/**
 *  Copies the values from another Matrix.
 *  Returns the matrix so the methods can be chained.
 *  @langversion 3.0
 *  @playerversion Flash 10.2
 *  @playerversion AIR 2.6
 *  @productversion Royale 0.7
 * @param {org.apache.royale.geom.Matrix} source
 * @return {org.apache.royale.geom.Matrix}
 */
org.apache.royale.geom.Matrix.prototype.copyFrom = function(source) {
  this.a = source.a;
  this.b = source.b;
  this.c = source.c;
  this.d = source.d;
  this.tx = source.tx;
  this.ty = source.ty;
  return this;
};


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
org.apache.royale.geom.Matrix.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'Matrix', qName: 'org.apache.royale.geom.Matrix', kind: 'class' }] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
org.apache.royale.geom.Matrix.prototype.ROYALE_REFLECTION_INFO = function () {
  return {
    variables: function () {
      return {
        'a': { type: 'Number', get_set: function (/** org.apache.royale.geom.Matrix */ inst, /** * */ v) {return v !== undefined ? inst.a = v : inst.a;}},
        'b': { type: 'Number', get_set: function (/** org.apache.royale.geom.Matrix */ inst, /** * */ v) {return v !== undefined ? inst.b = v : inst.b;}},
        'c': { type: 'Number', get_set: function (/** org.apache.royale.geom.Matrix */ inst, /** * */ v) {return v !== undefined ? inst.c = v : inst.c;}},
        'd': { type: 'Number', get_set: function (/** org.apache.royale.geom.Matrix */ inst, /** * */ v) {return v !== undefined ? inst.d = v : inst.d;}},
        'tx': { type: 'Number', get_set: function (/** org.apache.royale.geom.Matrix */ inst, /** * */ v) {return v !== undefined ? inst.tx = v : inst.tx;}},
        'ty': { type: 'Number', get_set: function (/** org.apache.royale.geom.Matrix */ inst, /** * */ v) {return v !== undefined ? inst.ty = v : inst.ty;}}
      };
    },
    methods: function () {
      return {
        'Matrix': { type: '', declaredBy: 'org.apache.royale.geom.Matrix', parameters: function () { return [ 'Number', true ,'Number', true ,'Number', true ,'Number', true ,'Number', true ,'Number', true ]; }},
        'clone': { type: 'org.apache.royale.geom.Matrix', declaredBy: 'org.apache.royale.geom.Matrix'},
        'concat': { type: 'org.apache.royale.geom.Matrix', declaredBy: 'org.apache.royale.geom.Matrix', parameters: function () { return [ 'org.apache.royale.geom.Matrix', false ]; }},
        'determinant': { type: 'Number', declaredBy: 'org.apache.royale.geom.Matrix'},
        'invert': { type: 'org.apache.royale.geom.Matrix', declaredBy: 'org.apache.royale.geom.Matrix'},
        'identity': { type: 'org.apache.royale.geom.Matrix', declaredBy: 'org.apache.royale.geom.Matrix'},
        'rotate': { type: 'org.apache.royale.geom.Matrix', declaredBy: 'org.apache.royale.geom.Matrix', parameters: function () { return [ 'Number', false ]; }},
        'translate': { type: 'org.apache.royale.geom.Matrix', declaredBy: 'org.apache.royale.geom.Matrix', parameters: function () { return [ 'Number', false ,'Number', false ]; }},
        'scale': { type: 'org.apache.royale.geom.Matrix', declaredBy: 'org.apache.royale.geom.Matrix', parameters: function () { return [ 'Number', false ,'Number', false ]; }},
        'deltaTransformPoint': { type: 'org.apache.royale.geom.Point', declaredBy: 'org.apache.royale.geom.Matrix', parameters: function () { return [ 'org.apache.royale.geom.Point', false ]; }},
        'transformPoint': { type: 'org.apache.royale.geom.Point', declaredBy: 'org.apache.royale.geom.Matrix', parameters: function () { return [ 'org.apache.royale.geom.Point', false ]; }},
        'toString': { type: 'String', declaredBy: 'org.apache.royale.geom.Matrix'},
        'copyFrom': { type: 'org.apache.royale.geom.Matrix', declaredBy: 'org.apache.royale.geom.Matrix', parameters: function () { return [ 'org.apache.royale.geom.Matrix', false ]; }}
      };
    }
  };
};
/**
 * @const
 * @type {number}
 */
org.apache.royale.geom.Matrix.prototype.ROYALE_COMPILE_FLAGS = 10;
